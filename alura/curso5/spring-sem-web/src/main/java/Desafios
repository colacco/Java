PARTE 1:

Em aula, conhecemos a mágica da JPA para lidar com classes e tabelas. Agora, seu objetivo é continuar praticando e ser capaz de comparar várias funcionalidades diferentes da JPA.

Para isso, você pode criar um novo projeto chamado gerenciador-pedidos, onde iremos trabalhar em classes de Produto e Pedido, por exemplo. Seu projeto deve ser do tipo “spring-sem-web” e deve ter as dependências do Spring JPA e do banco de dados PostgreSQL.

Tendo criado o projeto completo e configurado as configurações do banco no application.properties, você pode criar um banco de dados chamado gerenciador-pedidos também, conforme feito em aula.

Feito isso, estamos preparados para exercitar os conhecimentos. Vamos lá?

1 - Crie uma classe chamada Produto com os seguintes atributos: id (Long, chave primária) nome (String) preco (Double) Anote a classe com @Entity e mapeie o atributo id como chave primária com @Id. A classe deve ter um construtor e os getters.

2 - Modifique o exercício anterior para usar a anotação @GeneratedValue no campo id, com a estratégia de geração automática de identificadores (GenerationType.IDENTITY).

3 - Agora, iremos usar vários parâmetros da anotação @Column. Acrescente os seguintes requisitos à classe Produto: O atributo nome deve ser único e não nulo. O atributo preco deve ser armazenado em uma coluna chamada valor.

4 - Crie uma classe Categoria com os atributos: id (Long, chave primária) nome (String) A classe deve ter um construtor e os getters. Transforme a classe em entidade.

5 - Crie uma classe Pedido com os seguintes atributos: id (Long, chave primária) data (LocalDate) A classe deve ter um construtor e os getters. Transforme a classe em entidade.

6 - Execute a aplicação e veja se todas as tabelas foram criadas corretamente. Quando estiver tudo certo, podemos ir para o próximo passo.

7 - Agora, iremos querer salvar dados no banco. Por isso, você deve criar vários repositórios diferentes: um para Pedido, outro para Produto e outro para Categoria.

8 - Para finalizar, crie um objeto de cada classe e use os repositórios para salvar os dados. Tudo certo para executar os dados? Provavelmente faltará um passo bem importante. Tente se lembrar do que acontece na aula e fazer este último passo. Você também pode analisar o log de erro :) Caso ainda precise de ajuda, na “Opinião do instrutor” terá uma dica para te ajudar.

Extra (pra quem quer mergulhar mesmo): uma vez que seu programa tiver executado corretamente, você pode testar os vários tipos de GenerationType do id. Adicione vários registros diferentes, comparando como o id é inserido no banco de dados. Na prática, qual a diferença de cada um dos tipos de geração de id?

Faça a mesma coisa para os vários parâmetros de @Column. Como os parâmetros alteram as colunas? Para te ajudar nessa segunda parte, você pode usar alguma ferramenta de IA, pedindo sugestões de casos para testar. Depois, conte para a gente no fórum sobre sua experiência :)

PARTE 2:

1 - Relacione Categoria e Produto usando @OneToMany, permitindo que uma categoria tenha vários produtos. Assim, estamos definindo um relacionamento 1:n do lado da categoria. Aqui, ao salvarmos uma categoria, queremos salvar seus produtos automaticamente também. Faça a configuração necessária para atender a esse requisito.

2 - Repare que o relacionamento criado é unidirecional: somente a classe Categoria o enxerga. Podemos deixá-lo bidirecional, configurando um relacionamento do tipo n:1 do lado do Produto, com a anotação @ManyToOne.

3 - Na sua classe Principal, você pode criar várias categorias e produtos diferentes e fazer as associações correspondentes. Extra (pra quem quer mergulhar mesmo): Agora, iremos trabalhar com um novo tipo de relacionamento: o relacionamento muitos para muitos, que usa a anotação @ManyToMany.

Para esse relacionamento, geralmente é criada uma tabela intermediária entre as entidades. Pesquise como isso é feito e mapeie um relacionamento do tipo @ManyToMany entre Produto e Pedido, usando uma tabela intermediária. Dica: use a anotação @JoinTable, em conjunto com @JoinColumn.

Depois, associe produtos a pedidos na sua classe Principal.

4 - Crie uma nova classe Fornecedor, com os atributos id e nome. Transforme a classe em entidade.

5 - Configure um relacionamento unidirecional entre Fornecedor e Produto. O relacionamento deve ser mapeado na classe Produto. Logo, é nessa classe que deverá ter a anotação de relacionamento. Qual é a melhor anotação para usarmos neste caso?

6 - Faça as devidas associações entre Fornecedor e Produto na sua classe Principal.

PARTE 3:

Iremos continuar colocando os conhecimentos sobre a JPA em prática. Dessa vez, iremos explorar melhor as derived queries. Para isso, utilize a aplicação que você criou na lista de exercícios da aula 2, a gerenciador-pedidos. Vamos lá?

Aqui, iremos apresentar uma descrição da busca que você deve fazer no banco de dados. Sua tarefa é decidir em qual dos repositórios essa busca melhor se encaixa, e criar a derived query correspondente. Caso tenha alguma dúvida sobre as consultas, consulte a documentação do Spring.

1 - Retorne todos os produtos com o nome exato fornecido.

2 - Retorne todos os produtos associados a uma categoria específica.

3 - Retorne produtos com preço maior que o valor fornecido.

4 - Retorne produtos com preço menor que o valor fornecido.

5 - Retorne produtos cujo nome contenha o termo especificado.

6 - Retorne pedidos que ainda não possuem uma data de entrega.

7 - Retorne pedidos com data de entrega preenchida.

8 - Retorne produtos de uma categoria ordenados pelo preço de forma crescente.

9 - Retorne produtos de uma categoria ordenados pelo preço de forma decrescente.

10 - Retorne a contagem de produtos em uma categoria específica.

11 - Retorne a contagem de produtos cujo preço seja maior que o valor fornecido.

12 - Retorne produtos com preço menor que o valor fornecido ou cujo nome contenha o termo especificado.

13 - Retorne pedidos feitos após uma data específica.

14 - Retorne pedidos feitos antes de uma data específica.

15 - Retorne pedidos feitos em um intervalo de datas.

16 - Retorne os três produtos mais caros.

17 - Retorne os cinco produtos mais baratos de uma categoria.

PARTE 4:

Iremos continuar colocando os conhecimentos sobre a JPA em prática. Dessa vez, iremos explorar melhor as consultas JPQL. Para isso, utilize a aplicação que você criou na lista de exercícios da aula 2, a gerenciador-pedidos. Vamos lá?

1 - Crie uma consulta que retorne os produtos com preço maior que um valor

2 - Crie uma consulta que retorne os produtos ordenados pelo preço crescente.

3 - Crie uma consulta que retorne os produtos ordenados pelo preço decrescente.

4 - Crie uma consulta que retorne os produtos que comecem com uma letra específica.

5 - Crie uma consulta que retorne os pedidos feitos entre duas datas.

6 - Crie uma consulta que retorne a média de preços dos produtos.

7 - Crie uma consulta que retorne o preço máximo de um produto em uma categoria

8 - Crie uma consulta para contar o número de produtos por categoria.

9 - Crie uma consulta para filtrar categorias com mais de 10 produtos.

10 - Crie uma consulta para retornar os produtos filtrados por nome ou por categoria.

11 - Crie uma consulta nativa para buscar os cinco produtos mais caros
